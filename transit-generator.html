<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="threejs-imports.html">

<dom-module id="transit-generator">
	<template>
		<style>
			:host{
				display: block;
				position: relative;
			}
			#renderer{
				@apply(--layout-fit);
				overflow: hidden;
			}
			#renderer canvas{
				transform-origin: 0 0 0;
				-webkit-transform-origin : 0 0 0;
			}

		</style>

		<iron-ajax
			auto
			url="[[resolveUrl('frag.source.glsl')]]"
			handle-as="text"
			last-response="{{_fragmentShaderSource}}">
		</iron-ajax>

		<div id="renderer"></div>

	</template>
</dom-module>

<script>
	Polymer({
		is: 'transit-generator',
		properties: {
			numBalls:{
				type: Number,
				value: 20
			},
			maxResolution:{
				type: Number,
				value: 0.1,
				notify: true,
				observer: '_onResize'
			},
			deformationFrequency:{
				type: Number,
				value: 40,
				notify: true
			},
			deformationAmount:{
				type: Number,
				value: 0.6,
				notify: true
			},
			blobSize:{
				type: Number,
				value: 0.02,
				notify: true
			},
			timeMultiplier:{
				type: Number,
				value: 1,
				notify: true
			},
			halftoneGridSize : {
				type: Number,
				notify: true,
				value: 20
			},
			halftoneSeparation : {
				type: Number,
				notify: true,
				value: 1
			},
			halftonePrePower : {
				type: Number,
				notify: true,
				value: 1
			},
			halftonePostPower : {
				type: Number,
				notify: true,
				value: 1
			},
			halftoneMultiplier : {
				type: Number,
				notify: true,
				value: 1
			},
			_fragmentShaderSource: {
				type: String
			}
		},
		listeners:{
			'click' : 'screenshot'
		},
		observers:[
			'_setupRederer(_fragmentShaderSource, numBalls)'
		],
		ready: function () {
			window.META = this;
		},
		_setupRederer: function () {
			if(typeof this._fragmentShaderSource === 'undefined'){
				return;
			}
			if(typeof this.numBalls === 'undefined'){
				return;
			}
			this._renderer = new THREE.WebGLRenderer({
				precision: 'lowp'
			});
			renderer.autoClear = false;

			while(Polymer.dom(this.$.renderer).lastChild){
				Polymer.dom(this.$.renderer).removeChild(Polymer.dom(this.$.renderer).lastChild);
			}
			Polymer.dom(this.$.renderer).appendChild(this._renderer.domElement);

			var objects = [];
			for (var i = 0; i < this.numBalls; i++) {
				objects[i] = new THREE.Vector4(0,0,0, this.blobSize);
			}
			this._uniforms = {
				time : { type: "f", value: 0 },
				resolution : { type: "v2", value: new THREE.Vector2( 0.5, 0.5) },
				objectColor : { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) },
				backgroundColor : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) },
				baseLightColor : { type: "v3", value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },
				spotLightColor : { type: "v3", value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },
				spot2LightColor : { type: "v3", value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },
				deformationFrequency  : { type: "f", value: this.deformationFrequency },
				deformationAmount : { type: "f", value: this.deformationAmount },
				objects : { type : "v4v", value: objects },
				halftoneGridSize : { type: "f", value: this.halftoneGridSize },
				halftoneSeparation : { type: "f", value: this.halftoneSeparation },
				halftonePrePower : { type: "f", value: this.halftonePrePower },
				halftonePostPower : { type: "f", value: this.halftonePostPower },
				halftoneMultiplier : { type: "f", value: this.halftoneMultiplier },
				camera: { type: "v3", value: new THREE.Vector3( 0, 0, -1) },
				texture: { type: "t", value: new THREE.Texture( ) },
				cubemap: { type: "t", value: new THREE.Texture( ) }

			}

			this._composer = new THREE.EffectComposer( this._renderer );
			this._shader = new THREE.ShaderPass( {
				vertexShader : 'void main(){gl_Position = vec4( position, 1.0 );}',
				fragmentShader : this._fragmentShaderSource,
				uniforms: this._uniforms
			});
			this._shader.renderToScreen = true;
			this._composer.addPass( this._shader );

			/*this._filterShader = new THREE.ShaderPass( THREE.CopyShader );
			this._filterShader.renderToScreen = true;
			this._composer.addPass( this._filterShader );*/

			/*this._dotScreenShader = new THREE.ShaderPass( THREE.DotScreenShader );
			this._dotScreenShader .uniforms[ 'scale' ].value = 4;
			this._composer.addPass( this._dotScreenShader  );

			this._rGBShiftShader  = new THREE.ShaderPass( THREE.RGBShiftShader );
			this._rGBShiftShader .uniforms[ 'amount' ].value = 0.0015;
			this._rGBShiftShader .renderToScreen = true;
			this._composer.addPass( this._rGBShiftShader  );*/

			this._lastAnimationFrameTime = Date.now();
			window.requestAnimationFrame(this._animationFrame.bind(this));

			window.addEventListener('resize', this._onResize.bind(this), false);
			this._onResize();
		},

		_fluidPosition: function(value, i, array){
			var now = this._now();
			var index = i/array.length;
			var result = {};
			result.x = Math.sin(now*0.4 + index * 10);
			result.y = Math.cos(now + index * now*0.3) * 0.3;
			result.z = (Math.sin(now*0.7 + index * now*0.1) * 0.5 - 1.0) * 0.001;
			//result.z = result.z * 0.2 -1;

			return result;
		},
		_rigigPosition: function(value, i, array){
			return Math.sin(Date.now() * 0.001) - 1;
		},
		_constrainPositionsToUv: function(value, i, array){
			var result = {};
			result.x = (value.x * 0.5 - 0.5);
			result.y = (value.y * 0.5 - 0.5);
			result.z = value.z;
			return result;
		},
		_render: function(dt) {

			var objects = this._shader.uniforms.objects.value;
			var fluidPositions = objects.map(this._fluidPosition.bind(this));
			var finalPositions = fluidPositions.map(this._constrainPositionsToUv.bind(this));

			//var rigidPositions = objects.map(this._rigidPositions.bind(this));
			objects.forEach(function(value, i){
				value.x = fluidPositions[i].x;
				value.y = fluidPositions[i].y;
				value.z = fluidPositions[i].z;
				value.w = this.blobSize;
			}.bind(this));

			this._shader.uniforms.deformationFrequency.value = this.deformationFrequency;
			this._shader.uniforms.deformationAmount.value = this.deformationAmount;
			this._shader.uniforms.halftoneGridSize.value = this.halftoneGridSize;
			this._shader.uniforms.halftoneSeparation.value = this.halftoneSeparation;
			this._shader.uniforms.halftonePrePower.value = this.halftonePrePower;
			this._shader.uniforms.halftonePostPower.value = this.halftonePostPower;
			this._shader.uniforms.halftoneMultiplier.value = this.halftoneMultiplier;

			this._composer.render();
		},
		_onResize:function(){
			this.debounce('_onResize', function(){
				var screenSize = this.getBoundingClientRect();
				var resolution = Math.sqrt( (this.maxResolution * 1000000) / (screenSize.width * screenSize.height) );
				var canvasSize = {
					width: (screenSize.width * resolution ),
					height: (screenSize.height * resolution )
				}

				this._renderer.setSize(canvasSize.width, canvasSize.height);
				var scale = (1.0 / resolution) ;
				this.transform('scale3d('+scale+', '+scale+', 1.0)', this._renderer.domElement);

				//this._shader.uniforms[ 'resolution' ].value = new THREE.Vector2( canvasSize.width * window.devicePixelRatio, canvasSize.height * window.devicePixelRatio) ;
				this._shader.uniforms[ 'resolution' ].value = new THREE.Vector2( canvasSize.width, canvasSize.height) ;
				console.log(canvasSize.width)

			}, 100);
		},
		_animationFrame: function () {
			var dt = Date.now() - this._lastAnimationFrameTime;
			this._lastAnimationFrameTime = Date.now();
			this._render(dt);
			window.requestAnimationFrame(this._animationFrame.bind(this));
		},
		_now: function(){
			return Date.now() * 0.001 * this.timeMultiplier;
		},
		_constrainZ: function(z){
			return z * 0.005 + 0.001;
		},
		takeScreenshot: function(){
			this._composer.render();
			return this._renderer.domElement.toDataURL();
		}
	});
</script>
